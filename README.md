# STM32_I2CDriver

We will implement an I2C driver akin to the SPIDriver project that has already been done (meaning that we will use the same sensor as before and the same data processing calculations - see SPIDriver project).

## General description
I2C is the third in the series of communication protocols we may consider as “standard”. It is slower than SPI (with an absolute maximum of 3.5 MHz, albeit the standard maximum is 400 kHz) but uses only 2 pins to function. Unlike SPI where a sort of “branch-type” connection is necessary to have multiple slaves driven be the same master, we simply need to daisy chain I2C devices together using exactly the same circuit to allow multi-slave setups. Due to its relative simplicity, I2C is generally the preferred com protocol for most people if speed is not so crucial and if noise is relatively little of a concern.

### Master or slave?
Unlike SPI where the master-slave selection is done by writing to a specific bit within the driver register, an I2C driver can be either, dependent merely on if a start bit is generated by the device or not. I2C devices usually stand-by as slaves on the bus, thus they can be recognised on the bus even if they are otherwise behaving as masters.

### Who owns the bus?
One of the special things about I2C is that nobody really owns the bus…or more precisely, all communicating parties do. The ownership depends on who is sending data to who. Yet, even when the direction of communication is set, the ownership does not stay uniquely with the device that is sending the data. This is because each message on the bus most be followed by an acknowledgement (ACK) bit that the receiving party must send over to the trasnmitter, independent of if it is a master or a slave.

Sending an ACK is crucial for the I2C peripherals on each side of the com to understand, what is going on. It can signal that the next part of the message will be coming…or the end of it. ACKs are also used for slave devices to make themselves recognized by the master device.

The ACK always arrives after a byte has been sent over with some level of tolerance (which is called clock stretching and can be allowed in the registers).

### GPIOs
As mentioned before, we only need 2 pins to drivee the I2C bus. These are:
-	SCL: the clock line
-	SDA: the data line

Of note, both SCL and SDA need to be pulled HIGH with some pull-up resistors somewhere to make I2C work. That is a design demand. It is definitely possible to do this locally on the mcu GPIOs, though my experience suggests that using external 4.7k ohm resistors make the bus significantly more stable.

Be aware that I2C tends to be sensitive to noise. Long I2C traces can become loops - and thus, antennas - so it is recommended not to go too crazy with the slave daisy chains.

## Previous relevant projects
The following projects should be checked:
- STM32_ClockDriver (the PWM part not included)
- STM32_SPIDriver (due to using the same sensor here as there, the BMP280)

## To read
The following parts are necessary to be read:
- 28.4 I2C functional description (until 28.4.13): general description of how I2C works and how to set it up. Tables 129 and 130 are particularly important!
- 28.7 I2C registers

## Particularities

Unlike SPI which is always clocked from APB, we can choose I2C to be clocked by the APB by modifying a clock register, see the code for details.

There are two I2C drivers in the L0x3. We will be using I2C1 here, which is clocked on APB1. From the ClockDriver project, we know that APB1 – the bus, not the connected timer – clocks at 8 MHz. We aren’t going to pre-scale or multiply this to get to the frequency of the I2C, instead we will need to modify the TIMINGR registers. Luckily, Tables 129 and 130 on page 727 in the refman has the exact TIMINGR values we need to use, we just need to plug them into the right section of the register. (We will stay with 100 kHz speed, though putting it to 400 kHz is merely by plugging a different set of values in here, nothing fancy.)

We also have another particularity here, namely that unlike UART which was a blocking function by design and SPI which had to be forced to wait a bit between messages due to the speed difference between the sensor and the mcu, the I2C driver here – at least, how I wrote it – is completely non-blocking, meaning that a delay function MUST be implemented as each shift register is being loaded, otherwise the values on the shift regsiter will be overwritten/corrupted before they are sent out. Additionally, in order to move along with the bus as it changes iwners, we should capture the ACK bit after a byte is sent over (that is, stop owning the bus ans lsiten for a reply), otherwise the next phase of the communication could not be predicted. The easy way is to wait for an ACK, the fancy would be to use IRQs on both Tx and Rx. (I chose here the easy way.)

Within my code, there is another in-built delay for turning the I2C on and off. This is a demand by the driver itself, i.e. to keep the PE control bit the same for at least three SYSCLK cycles to take effect. With the ClockDriver, our smallest delay is 1 us, so I put that one here. (With HAL, it would be 1 ms, which is obivosuly significantly greater.)

I2C has an Rx and a Tx side, both with their own buffer.

A Tx must always come before any Rx so as to tell the slave, which register we want to read from. Thus, all readout must be preceded by a writing to the slave and tell it to select/prepare the specific register for a readout.

There are filters and additional controls elements that should help stabilize the bus better. These may or may not be necessary, I recommend using some form of filter and clock stretching when using jumper cables on a breadboard to avoid the bus collapsing due to noise. For a more tight design (using PCBs instead of jumper cables), these may not be necessary.

### What is the actual address?
The actual addressing is different compared to SPI. Unlike there, where we “add” the appropriate MSB to the 7-bit addresses to decide if we want to read or write to a register, within I2C, with “add” the LSB. This means that a device, whose actual address is 0x40, will have a “write address” of 0x80 (0x40 plus an extra LOW bit added on LSB) and a “read address” of 0x81 (0x40 plus an extra HIGH bit added on LSB). As such, even though we will plug 0x80 or 0x81 into our code, the actual device address will be 0x40. The line (addr << 1) comes up often in this scenario, which technically means that we add an extra LSB to the address we have. Mind, this practically means that we cut of the MSB from an address that is longer than 8 bits, since when we copy this modified address into an 8-bit register, the MSB simply would not fit in there.

### DMA and IRQ
DMA can be used on I2C to speed it up. Frankly, I have not had a project yet where this was necessary, the command-and-control systems that I have built until now had been tolerant enough to a bit of delay until I2C was done. At any rate, DMA could be implemented to improve the I2C.

Using IRQs is also an option since we have the I2C interrupt generated after a successful Tx with an ACK from the slave (no interrupt of there was no ACK from the slave) and after the Rx buffer is successfully filled. It is possible to build a driver-IRQ interplay to allow the mcu to fire-and-forget the driver until it has sent over or collected the data. Nevertheless, just like doing DMA, having an IRQ would make this project more complicated than necessary. (Just to be clear, back in the UARTDriver project I used IRQs because I deemed it necessary due to the lack of a master.)

## User guide
We should be aware that the guide above only describes, how to set up the hardware to behave as an I2C master. Afterwards though, we still need to control this hardware in a way that I2C-compliant messages will be formed. The datasheet of the specific sensors used usually detail, how I2C messages are constructed so I won't detail them here. The only thing to be aware of is that our peripheral generates a "start" on the bus when the start bit is set and the Tx buffer is loaded…and a "stop" when the appropriate NACK is being received. (This is is not the same across all families of STM32, in some one needs to manually generate a "start" condition by setting some register bits.)

In the code presented here, we have 7-bit device addressing with the read/write bit automatically added to this device address within the peripheral when the appropriate write/read bits and the buffers are set.

Wwe don’t have a master-slave division here. Whoever is generating a start bit, is the master. This means that, given the own address for our device is enabled, we can use another device and detect our (inactive) first one on the bus as a slave device. We can build an I2C scanner using the L0x3, which will then go and send a response request message through the bus to all 128 possible addresses. When it receives an ACK, that means there was a device on the bus with that particular address (again, the bus is shared so all devices here the message, it is just that they don’t react to it if they aren’t the ones being called). Such function is very useful to detect devices on the bus.

Mind, unlike SPI where the message array’s first element was the register address we intended to write to (with the appropriate MSB set to indicate writing or reading), here we have an additional address to pick the slave. That address must be sent first, followed by the actual register address, this time without any modifications on the MSB. This pretty much comes up only when dealing with the reset and the control register, which is going to be on 0xE0 and 0xF4 respectively, independent of writing or reading (as a reminder, on SPI, writing direction was the register address 0x74, reading was 0xF4). Technically, in SPI we directly wrote and read from the registers once we have chosen the slave using the CS/SS, but in I2C, we choose the slave using the address…and define if we want to write or read from the slave by adding a HIGH or LOW LSB to the address. Afterwards, we don’t change the register addresses, since we already know if we wanted to write or read. (I know this is a bit confusing, but let’s not forget that we don’t have a lot of registers in the BMP280 and we have SPI AND I2C capabilities at the same time. So yeah, this SPI/I2C merging trick would not work for sensors that have more than 128 registers to modify.)

When we Tx to a slave, we may not write to it. A Tx message can actually just choose a register for readout which is then read out by sending an Rz command to the slave. It is best to think of it as directly "controlling" the slave, not communicating with it. 

For a full know-how on how the BMP280 sensor works, read the datasheet provided in the SPIDriver project or check the SPIDriver project. The data processing is identical with what was used in this project.

(I used this page a lot to understand I2C, especially how the messages are physically built up: I2C Bus Technical Overview and FAQ - EmSA (esacademy.com))
